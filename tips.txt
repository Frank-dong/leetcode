1. 在解题中如果有排序的需要，首选使用系统提供的快排接口qsort(435等涉及排序的题目)

2. 部分情况下，可以降低要求，使用全局变量来辅助完成题解

3. 可以在函数中定义未知大小的数组，但是不能在定义时初始化，而是在使用前手动清空。

4. 有时可以借助静态局部变量，或者比较难操作时借助全局变量方便快速解题(2.c).

5. 在全局中寻找子集的一些题目，可以采用滑动窗口的思想解题，不同条件下移动窗口左右边界。在使用滑动窗口时一定要注意边界条件(3.c, 16)

6. 在纯字符的题目，如果涉及到字符的统计，查重等操作时，可以直接定义一个字符数组来实现，利用下标来方便统计各个字符查询的次数. 可以理解定义一个字符数组相当于是简单的hash操作

7. 使用bool值时需要包含 <stdbool.h>

8. 注意代码中赋值运算中的"=", 不要写成了"=="

9. 32位有符号整数的范围时0x80000000 ~ 0x7fffffff, 对应的是 -2147483648 ~ 2147483647, 这里要注意最小值的表示是0x80000000, 负数是以补码形式保存的. 在代码中可以使用INT_MIN和INT_MAX(limits.h)，如果使用0x80000000这样的值，应该前面加上int强转， (int)0x80000000, (int)0x7fffffff. 防止在64位机器上当作64位的数来比较。

10. 整数从个位开始往高位取值的时候，可以使用取余的方式获取地位的值，然后更新原值; 从高位逐个向低位取数值时，可以先低到高取商值，求得最高为的进制数。比如1234567，可以不断除10，得到最高进制是1000000, 然后取商就是最高位的值，然后进制也除10，取次高位，如此循环。

11. 题目的求解过程如果是满足求得局部最优解就是整体最优解的情况，就可以考虑使用贪心算法来解决。这类题的特征是前后两次求解过程没有关系，相互不依赖. (12 13)

12. 某些多个整型数，或者多个字符串等等题目求解时，如果没有思路，可以考虑先进行排序，找找思路。(15)

13. 对于前后匹配的题目，考虑使用栈结构来处理。简单的可以使用数组来实现一个栈，根据下标来访问元素。复杂点的，可以很快写一个栈接口，辅助解题。

14. 二分查找过程最好写出= < > 三个分支结构，方便理解。同时考虑题目中是寻找左边界，还是有边界

15. 在答题时，有些题目中传入的指针变量可能指向一个未初始化的变量，直接通过*访问其值可能导致错误，所以保险起见，在使用前强制赋值为0. 所有题目中给出的变量，在使用之前都要做初始化操作。(46)

16. 回溯算法的大框架是：
	backtrack(选择列表，结果列表):
		if 结束条件：
			添加到结果列表
			return

		for i in 选择列表：
			选择路径
			backtrack()
			撤销选择
	
		return
	在这类题目中需要注意的几点：
	a. 结束条件
	b. 回调函数参数列表
	c. for循环选择不同路径
	d. 路径选择方式和撤销方式

17. ++的优先级高于*，所以如果要自增一个指针变量指向的值 *p++是错误的，应该是(*p)++. 这些情况下，不论优先级高低，最好带上括号，显示的表示出运算优先级

18. 二维数组的传递一定要在参数列表中指明第二维度的大小, 比如 int array[][10], 这就表明传递一个二维数组，第二维度的大小为10个整型数数。 如果题目中传的是二级指针，那么第一纬度的步进单位就是一个指针大小。(37)

19. 涉及到在图结构中寻找最短距离的相关问题，都适用于广度优先算法BFS，广度优先关键在于记录各个点的距离. (111)

20. 在代码中取两个值得最大值，可以用三目运算符，但是建议使用fmax()函数，包含头文件math.h，编译时链接-lm

21. 需要罗列的题目通常来说需要通过回溯法，或者动态规划法来求解，在求解过程中，如果没有思路，可以试着罗列几组数据，从中找找规律，推导出状态转移方程

22. 递归形式的关键是要能抽象出一个个的子问题，先把子问题视为一个整体，然后子问题是一个小规模的原问题。入此嵌套就是递归的过程。思考以下汉诺塔的过程




方法整理：
1. 滑动窗口法
2. 双指针法(左右指针、快慢指针)
3. 回溯法
4. 动态规划
5. 借助栈、队列
6. 二分法
7.
