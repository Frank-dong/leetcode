1. 在解题中如果有排序的需要，首选使用系统提供的快排接口qsort(435等涉及排序的题目)

2. 部分情况下，可以降低要求，使用全局变量来辅助完成题解

3. 可以在函数中定义未知大小的数组，但是不能在定义时初始化，而是在使用前手动清空.但是这个未知大小是外部给的话，或者预估可能会很大的时候，可能回导致函数栈溢出，所以此时还是使用动态申请的方式.

4. 有时可以借助静态局部变量，或者比较难操作时借助全局变量方便快速解题(2.c).

5. 在全局中寻找子集的一些题目，可以采用滑动窗口的思想解题，不同条件下移动窗口左右边界。在使用滑动窗口时一定要注意边界条件(3.c, 16)

6. 在纯字符的题目，如果涉及到字符的统计，查重等操作时，可以直接定义一个字符数组来实现，利用下标来方便统计各个字符查询的次数. 可以理解定义一个字符数组相当于是简单的hash操作

7. 使用bool值时需要包含 <stdbool.h>

8. 注意代码中赋值运算中的"=", 不要写成了"=="

9. 32位有符号整数的范围时0x80000000 ~ 0x7fffffff, 对应的是 -2147483648 ~ 2147483647, 这里要注意最小值的表示是0x80000000, 负数是以补码形式保存的. 在代码中可以使用INT_MIN和INT_MAX(limits.h)，如果使用0x80000000这样的值，应该前面加上int强转， (int)0x80000000, (int)0x7fffffff. 防止在64位机器上当作64位的数来比较。

10. 整数从个位开始往高位取值的时候，可以使用取余的方式获取低位的值，然后更新原值; 从高位逐个向低位取数值时，可以先低到高取商值，求得最高为的进制数。比如1234567，可以不断除10，得到最高进制是1000000, 然后取商就是最高位的值，然后进制也除10，取次高位，如此循环。

11. 题目的求解过程如果是满足求得局部最优解就是整体最优解的情况，就可以考虑使用贪心算法来解决。这类题的特征是前后两次求解过程没有关系，相互不依赖. (12 13, 435)

12. 某些多个整型数，或者多个字符串等等题目求解时，如果没有思路，可以考虑先进行排序，找找思路。(15)

13. 对于前后匹配的题目，考虑使用栈结构来处理。简单的可以使用数组来实现一个栈，根据下标来访问元素。复杂点的，可以很快写一个栈接口，辅助解题。

14. 二分查找过程最好写出= < > 三个分支结构，方便理解。同时考虑题目中是寻找左边界，还是有边界.(35)

15. 在答题时，有些题目中传入的指针变量可能指向一个未初始化的变量，直接通过*访问其值可能导致错误，所以保险起见，在使用前强制赋值为0. 所有题目中给出的变量，在使用之前都要做初始化操作。(46)

16. 回溯算法本质上就是DFS算法，是一个决策树的遍历过程，是一种暴力枚举的过程。在决策过程中配合适当的判断条件，排除掉一些不要的情况，这个叫剪枝的过程。(22, 46)

17. ++的优先级高于*，所以如果要自增一个指针变量指向的值 *p++是错误的，应该是(*p)++. 这些情况下，不论优先级高低，最好带上括号，显示的表示出运算优先级.

18. 二维数组的传递一定要在参数列表中指明第二维度的大小, 比如 int array[][10], 这就表明传递一个二维数组，第二维度的大小为10个整型数。 如果题目中传的是二级指针，那么第一纬度的步进单位就是一个指针大小。(37)

19. 涉及到在图结构中寻找最短距离的相关问题，都适用于广度优先算法BFS，广度优先关键在于记录各个点的距离.BFS处理时是同一层的节点齐头并进，每次入队一层的节点，等处理完了之后，再进行下一轮的处理 (111)

20. 在代码中取两个值得最大值，可以用三目运算符，但是建议使用fmax()函数，包含头文件math.h，编译时链接-lm

21. 需要罗列的题目通常来说需要通过回溯法，或者动态规划法来求解，在求解过程中，如果没有思路，可以试着罗列几组数据，从中找找规律，推导出状态转移方程

22. 递归形式的关键是要能抽象出一个个的子问题，先把子问题视为一个整体，然后子问题是一个小规模的原问题。入此嵌套就是递归的过程。思考以下汉诺塔的过程




题型和方法整理：
1. 滑动窗口法
	while (right < SIZE):
		// 扩大窗口
		right++
		
		while (需要缩小窗口了吗?):
			// 缩小窗口
			left++
	两层循环，外层循环是不断扩大窗口，也就是移动右边界，进入里面循环的条件是右边界移动到了一个临界状态，此时需要移动左边界。一直到左边界也到了临界状态，此时可能就是一个解，记录这个解，跳出循环，在外循环移动右边界，探索新的解。
	更加通用的应该是：
	while (左右边界的合理临界判断):
		// 修改一个边界x
		// 改变x的值

		while (到达x的临界条件):
			// 修改另外一个边界y
			// 改变y的值
			if (有合理解):
				记录该解
				break
		

2. 双指针法(左右指针、快慢指针)
	左右指针的应用场景：比如二分查找、快速排序、滑动窗口等等,主要特定是两个指针定位一个区间，不断修改其中一个指针，寻求答案。
	快慢指针：主要适用于链表题目中的一些情况。通过两个不同步进单位的指针，在某种情况下形成一个边界条件，帮助解决问题。

3. 回溯法
	backtrack(选择列表，结果列表):
		if 结束条件：
			添加到结果列表
			return

		for i in 选择列表：
			选择路径
			backtrack()
			撤销选择
	
		return
	在这类题目中需要注意的几点：
	a. 结束条件
	b. 回调函数参数列表
	c. for循环选择不同路径
	d. 路径选择方式和撤销方式
	e. 多次递归中的共有变量，一定要采用传地址的方式，不能使用传值的传参方式。
	
4. 动态规划
	动态规划是一种自底向上解决问题的方法，就是先从子问题入手，计算完子问题，然后计算下一过程的解，这样就可以避免重复计算。
	动态规划是从递归逐渐演变过来的，递归通常是自上而下的解决问题，在递归中增加备忘录也能减少子问题的重复计算。改成自下而上，先计算子问题的方式，就可以使用循环迭代替换递归的方式，配合dp数组来求解问题。
	这类问题通常具有可以递推归纳的特点，所以在没有思路的情况下，可以先从子问题罗列几个过程，从中找找规律，然后写出状态转移方程。写完后其实还可以寻求空间复杂度的优化。

5. 借助栈、队列
	栈和队列都是在解题中用来存放中间数据的结构，根据不同的缓存规则来选择。 

6. 二分法
	二分法就是将整体分成两部分，然后在两部分上进行(相同的)处理，就是分治的思想，比分二分查找，通过选择左右两边来所限查找范围。归并排序也是分别左右两边处理.
	二分查找的框架:
	while (left <= right):
		mid = (right - left) + left;
		if (num[mid] == target):
			// 找到目标
			break
		else if (num[mid] < target):
			left = mid + 1
		else if (num[mid] > target):
			right = mid - 1

	归并排序框架:
	merge_sort(nums, start, end) {
		// 结束条件
		if (start >= end):
			return

		// 先分
		mid = (start + end)/2
		merge_sort(nums, start, mid)	// 分别处理左右半部
		merge_sort(nums, mid + 1, end)

		// 再合
		merge(nums, start, mid, end)
	}

7. 排序(冒泡，快排，归并, 插入，希尔, 选择)
8. 查找(二分查找)
9. 贪心算法
	在求解过程中发现，局部最优解最终可以得到全局的最优解，那就适用贪心算法来处理。
	具体操作就是每次在选项中做出当前最佳的选项即可。 




华为机试注意事项(牛客网)：
1. 是ACM模式，需要自己写全部代码，包括输入速出。

2. 获取输入使用scanf，多个case的，使用:
	while (scanf("%s", input_buf) != EOF) {}	// 遇到空格会返回
	while (gets(input_buf) != NULL) {}	// 读取整个行, 也可以使用fgets(input_buf, 1024, stdin)
	如果是一行中有空格分割数字，可以采用上面的方式一次读取完，然后解析，也可以使用scanf和getchar来读取：
	scanf读取到空格或者回车时就退出了，此时用getchar再读取一个,用来判断回车，判断结束。
	while (scanf("%d", &num) != EOF) {
		if (getchar() == '\n') {
			//xxx
		}
	}

	注意，scanf读取时遇到空格就退出了，为了避免这样，可以这样读取 scanf("%[^\n]%*c", input_buf), 就是遇到\n再返回，后面的%*c是为了再多读走一个字符，就是\n,不然就\n还在输入缓存里，一直死循环返回.

3. 时间转换相关的接口
	获取当前时间 gettimeofday(struct timeval* t); t->tv_usec, t->tv_sec; <sys/time.h>

	将当前日期转换成时间戳整数 time_t mktime(struct tm* tm); time_t其实是一个long long int类型 tm->tm_year/tm_mon/tm_mday/tm_hour/tm_min/tm_sec/tm_isdst(夏令时 0);

	将时间戳数转换为时间信息 struct tm* localtime(time_t tm);
