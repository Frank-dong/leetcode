1. 在解题中如果有排序的需要，首选使用系统提供的快排接口qsort(435等涉及排序的题目)

2. 部分情况下，可以降低要求，使用全局变量来辅助完成题解

3. 可以在函数中定义未知大小的数组，但是不能在定义时初始化，而是在使用前手动清空。

4. 有时可以借助静态局部变量，或者比较难操作时借助全局变量方便快速解题(2.c).

5. 在全局中寻找子集的一些题目，可以采用滑动窗口的思想解题，不同条件下移动窗口左右边界。在使用滑动窗口时一定要注意边界条件(3.c, 16)

6. 在纯字符的题目，如果涉及到字符的统计，查重等操作时，可以直接定义一个字符数组来实现，利用下标来方便统计各个字符查询的次数. 可以理解定义一个字符数组相当于是简单的hash操作

7. 使用bool值时需要包含 <stdbool.h>

8. 注意代码中赋值运算中的"=", 不要写成了"=="

9. 32位有符号整数的范围时0x80000000 ~ 0x7fffffff, 对应的是 -2147483648 ~ 2147483647, 这里要注意最小值的表示是0x80000000, 负数是以补码形式保存的. 在代码中可以使用INT_MIN和INT_MAX(limits.h)，如果使用0x80000000这样的值，应该前面加上int强转， (int)0x80000000, (int)0x7fffffff. 防止在64位机器上当作64位的数来比较。

10. 整数从个位开始往高位取值的时候，可以使用取余的方式获取地位的值，然后更新原值; 从高位逐个向低位取数值时，可以先低到高取商值，求得最高为的进制数。比如1234567，可以不断除10，得到最高进制是1000000, 然后取商就是最高位的值，然后进制也除10，取次高位，如此循环。

11. 题目的求解过程如果是满足求得局部最优解就是整体最优解的情况，就可以考虑使用贪心算法来解决。这类题的特征是前后两次求解过程没有关系，相互不依赖. (12 13)

12. 某些多个整型数，或者多个字符串等等题目求解时，如果没有思路，可以考虑先进行排序，找找思路。(15)

13. 对于前后匹配的题目，考虑使用栈结构来处理。简单的可以使用数组来实现一个栈，根据下标来访问元素。复杂点的，可以很快写一个栈接口，辅助解题。

14. 二分查找过程最好写出= < > 三个分支结构，方便理解。同时考虑题目中是寻找左边界，还是有边界
