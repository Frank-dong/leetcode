#include <stdio.h>
#include <stdlib.h>

/**
 * 冒泡排序 (升序)
 */
int bubble_sort(int* nums, int numsSize)
{
    int i = 0;
    int j = 0;
    int tmp = 0;

    for (i = 0; i < numsSize; ++i) {
        for (j = i; j < numsSize; ++j) {
            if (nums[i] > nums[j]) {
                tmp = nums[i];
                nums[i] = nums[j];
                nums[j] = tmp;
            }
        }
    }

    return 0;
}

#define SWAP_BY_BYTE(a, b, size)    \
do {                                \
    int     unit_size = (size);     \
    char*   pa = (a), *pb = (b);     \
    char    tmp;                    \
    do {                            \
        tmp = *pa;                  \
        *pa++ = *pb;                \
        *pb++ = tmp;                \
    } while (--unit_size > 0);      \
} while (0)


/**
 * 冒泡排序，自定义升序或降序
 * 上面的算法的缺点是只能针对固定类型的数据，并且
 * 顺序方向固定
 * 
 * 改进为：增加单元大小参数和比较函数，这样就将数
 * 据类型和顺序方向解耦，交给用户。
 * 规定：如果升序排列，则compar返回比较数1和比较
 * 数2做差的结果；如果是降序排列，做返回做差结果
 * 符号取反
 * 
 * 这里面有个问题，在交换的时候，由于不知道数值单
 * 元的大小，而交换时需要一个临时空间，如果不动态
 * 申请空间的话，可以采用单个字节来完成多字节的交
 * 换
 */
int bubble_sort_d(void* nums, int unit_size, int numsSize, 
                            int (*compar)(void*, void*))
{
    int i = 0;
    int j = 0;
    void* tmp = 0;

    for (i = 0; i < numsSize; ++i) {
        for (j = i; j < numsSize; ++j) {
            if (compar(nums+i*unit_size, nums+j*unit_size) > 0) {
                SWAP_BY_BYTE(nums+i*unit_size, 
                    nums+j*unit_size, unit_size);
            }
        }
    }

    return 0;
}

