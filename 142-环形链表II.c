/********************************************************
 * 给定一个链表，返回链表开始入环的第一个节点。 如果链表
 * 无环，则返回 null。
 *
 * 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾
 * 连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，
 * 则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，
 * 并不会作为参数传递到函数中。
 * ******************************************************/

/**
 * 在链表中操作的可以选择使用快慢双指针的方法。
 *
 * 这个题目主要是考虑如果链表中有环，那么遍历的指针就会陷入
 * 死循环，此时以何种条件判断结束。
 * 首先想到这是个查重问题，那么就可以采用做记录的方式，每遍历
 * 一个节点，就记录一个节点，遍历下一个的时候从记录里面查找。
 * 那就要看记录方式，如果采用线性记录方式，势必时间复杂度就
 * 是O(n^2)，爆炸级别，不行。 那就要想其他记录方式，比如哈希表
 * 由于C语言没有现成的接口使用，实现起来麻烦，所以先考虑记录
 * 方法以外的其他方式。
 *
 * 可以想到用两个指针，前后 遍历，在某种条件下，可以判断结束。
 * 这两个指针的前进速度不能相同，如果相同，就会牵手一起陷入
 * 死循环。所以要有速度差。最简单的就是一个步进单位1，一个步
 * 进单位2.一快一慢.这样快指针首先进入循环，慢指针后进入，
 * 而且由于速度不同，两个指针会相遇。此时就是判断条件成立的时候
 *
 * 然后再思考找出环的入口。通过上面分析可以知道，快慢指针相遇
 * 快指针走了2K步，慢指针走了K步。而快指针多走的K步，就是在
 * 环里转圈圈，也就是K步等于环的长度的整数倍. 假设相遇点距离
 * 入口为M,那么快指针再走K-M步就可以到入口处，但是到目前为止
 * 并不知到K和M具体是几，所以无法定量计算。画图观察可知，慢
 * 指针回退M步，也就到了入口处，而慢指针回退M步，就相当于从头
 * 重新走K-M步，所以在两者相遇后，只需要慢指针回到开头，然后
 * 两个指针以相同的速度前进，再次相遇，就是入口处。
 */
struct ListNode {
	int val;
	struct ListNode *next;
};

struct ListNode *detectCycle(struct ListNode *head) {
	struct ListNode*    fast = head;
	struct ListNode*    slow = head;

	while (slow && fast && fast->next) {
		slow = slow->next;
		fast = fast->next->next;
		if (slow == fast) {
			break;
		}
	}
	// 无环
	if (!slow || !fast || !fast->next)
		return NULL;

	// 寻找环入口
	slow = head;
	while (slow != fast) {
		slow = slow->next;
		fast = fast->next;
	}
	return slow;
}
