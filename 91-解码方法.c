/********************************************************
 * 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
 *
 * 'A' -> 1
 * 'B' -> 2
 * ...
 * 'Z' -> 26
 * 要 解码 已编码的消息，所有数字必须基于上述映射的方法，
 * 反向映射回字母（可能有多种方法）。例如，"11106" 可以
 * 映射为：
 *
 * "AAJF" ，将消息分组为 (1 1 10 6)
 * "KJF" ，将消息分组为 (11 10 6)
 * 注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射
 * 为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。
 *
 * 给你一个只含数字的 非空 字符串 s ，请计算并返回
 * 解码方法的总数 。
 *
 * 题目数据保证答案肯定是一个 32 位 的整数。
 *
 * ******************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/**
 * 先通过罗列一些数据，从中找找演变的规律，然后确定状态转移方程
 * 假设字符串是122034
 * 由于编码只有一个数字和两个数字的情况，逐一罗列找规律
 * 1:		1	(只有一个)
 * 12:		1,2; 12
 * 122:		1,2,2; 12,2; 1,22
 * 1220:	1,2,20; 12,20
 * 12203:	1,2,20,3; 12,20,3
 * 122034:	1,2,20,3,4; 12,20,3,4
 *
 * 找规律:
 * 观察每次新增一个数字形成的解与上一过程的解的关系,如果新增数
 * 字不是0，那么可以给上一结果的所有解后增加新数字，形成新解，
 * 也就是这部分和上一结果个数相同.
 * 由于不可能有三个数字的编码，刚才已经枚举完了单个数字结尾的解，
 * 现在看双数结尾的解，此时就要看上一结果中单个数字结尾的解的个
 * 数，并且能与新数字组成合理的数字.
 *
 * 同时注意到如果新增数字是0，那么只能与上一结果中的单数字结尾
 * 的解来结合。
 * 如果新增数字上一个数字形成无效编码(比如上面的34),那么新增数
 * 字就只能单独为一个编码，也就是与上一过程的解的个数相同.
 *
 * 通过上面分析发现，当前过程的解的个数与上一结果的所有个数和
 * 单数字结尾的个数有关。此时可以写出状态转移方程如下：
 *
 * F(n) = {
 *		= 1 (n = 1)
 *		= f(n-1) + single(n-1)	(num[n-1]num[n]是有效编码)
 *		= f(n-1)				(num[n-1]num[n]是无效编码)
 *		= single(n-1)			(num[n] = 0);
 * }
 *
 * 下面这个代码还有再优化的空间
 * 当前结果只与上一结果的个数和上一结果中单数字结尾的解有关，
 * 所以只需要两个变量来存储结果即可，空间复杂度优化为O(1)
 */
int numDecodings(char * s)
{
	int		len = strlen(s);
	int*	dp = calloc(1, sizeof(int)*(len));
	int		i = 0;
	int		sig_num = 0;

	for (i = 0; i < len; ++i) {
		if (i == 0) {
			if (s[i] != '0') {
				dp [i] = 1;
				sig_num = 1;
			}
			continue;
		}
		if (s[i] != '0') {
			if (s[i - 1] != 0 && (strncmp(s + i - 1, "26", 2) <= 0)) {
				dp[i] = dp[i-1] + sig_num;
			} else {
				dp[i] = dp[i-1];
			}
			sig_num = dp[i-1];
		} else {
			// 由于不会出现类似40 50 这样的编码，所以这里不用判断
			// 错了，会出现，出现则作为错误处理，返回0
			if (s[i - 1] != 0 && (strncmp(s + i - 1, "26", 2) <= 0)) {
				dp[i] = sig_num;
				sig_num = 0;
			} else {
				return 0;
			}
		}
	}
	return dp[len - 1];
}

void main(int argc, char* argv[])
{
	printf("%d\r\n", numDecodings(argv[1]));
}
